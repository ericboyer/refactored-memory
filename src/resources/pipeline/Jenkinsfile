pipeline {
    environment {
        appName = "refactored-memory"
        frontendImageName = "${appName}-frontend"
        backendImageName = "${appName}-backend"
        devProject = "${appName}-dev"
        prodProject = "${appName}-prod"
        // TODO Fix devTag to start with the most recent successful build
        devTag = "0.0.0"
        prodTag = ""
        destApp = "${imageName}-green"
        activeApp = ""
    }
    agent {
        kubernetes {
            cloud "openshift"
            label "build-pod"
            serviceAccount "jenkins"
            yamlFile "src/resources/openshift/build-pod.yaml"
        }
    }
    stages {
        stage('Configure Prereqs') {
            steps {
                container('python') {
                    script {
                        def version = sh(returnStdout: true, script: "python3 setup.py --version | cut -f1,2 -d.")
                        // Set the tag for the development image: version + build number
                        def withExtraChars = "${version}." + currentBuild.number
                        devTag = withExtraChars.replaceAll("[\r\n|\n\r|\n|\r]", "")

                        // Set the tag for the production image: version
                        prodTag = "${version}"
                    }

                    sh 'python3 --version'
                    sh 'python3 -m pip install --user --upgrade -r requirements.txt'
                }

                dumpPipelineConfig()
            }
        }
        stage('Package') {
            steps {
                container('python') {
                    sh 'python3 setup.py sdist bdist_wheel'
                }
            }
        }
        stage('Unit Test') {
            steps {
                container('python') {
                    sh 'python3 -m pytest tests'
                }
            }
        }
        stage('Archive') {
            steps {
                container('python') {
                    sh 'python3 -m twine upload --config-file /etc/config/.pypirc -r pypi-internal dist/*'
                }
            }
        }
        stage('Tag') {
            when {
                branch 'dev'
            }
            steps {
                sh "git tag v${devTag}"
                sh "git push origin --tags"
            }
        }
        stage('Static Analysis (sonarqube)') {
            environment {
                scannerHome = tool name: 'sonarqube-scanner', type: 'hudson.plugins.sonar.SonarRunnerInstallation'
                pylintReportPath = "pylint-report"
                projectSettings="."
                sources="src/refactored_memory"
                tests="tests"
                sourceEncoding="UTF-8"
                token="b9e37fece5e12ade8326f2d455749090732f0a48"
            }

            steps {
                container('python') {
                    script {
                        try {
                            sh 'pylint ${WORKSPACE}/src/refactored_memory \
                                -r n \
                                --msg-template="{path}:{line} [{msg_id}({symbol}), {obj}] {msg}" \
                                2>&1 ${pylintReportPath}'
                        } catch (err) {
                            echo err.getMessage()
                            echo "Error detected but continuing on "
                        }
                    }
                }
                container('jnlp') { // switch to container with a JVM
                    withSonarQubeEnv('sonarqube') {
                        sh "${scannerHome}/bin/sonar-scanner \
                                    -Dsonar.projectName=${devProject} \
                                    -Dsonar.projectKey=${devProject} \
                                    -Dsonar.host.url=${env.SONAR_HOST_URL} \
                                    -Dsonar.login=${token} \
                                    -Dsonar.settings=${projectSettings} \
                                    -Dsonar.sources=${sources} \
                                    -Dsonar.tests=${tests} \
                                    -Dsonar.sourceEncoding=${sourceEncoding} \
                                    -Dsonar.python.pylint.reportPath=${pylintReportPath}"
                    }
                }
            }
        }
//        stage("Quality Gate") {
//            steps {
//                timeout(time: 1, unit: 'HOURS') {
//                    waitForQualityGate abortPipeline: true
//                }
//            }
//        }
        stage('Build App Container(s)') {
            parallel {
                stage("Build backend") {
                    steps {
                        container('python') {
                            timestamps {
                                // build backend container and tag with current version
                                sh "oc -n ${devProject} start-build bc/${backendImageName} --wait"
                                sh "oc -n ${devProject} tag ${devProject}/${backendImageName}:latest ${devProject}/${backendImageName}:${devTag}"
                            }
                        }
                    }
                }
                stage("Build frontend") {
                    steps {
                        container('python') {
                            timestamps {
                                // build frontend container and tag with current version
                                sh "oc -n ${devProject} start-build bc/${frontendImageName} --wait"
                                sh "oc -n ${devProject} tag ${devProject}/${frontendImageName}:latest ${devProject}/${frontendImageName}:${devTag}"
                            }
                        }
                    }
                }
            }
        }
        stage('Deploy App(s) to Dev') {
            steps {
                container('python') {
                    // deploy backend
                    sh "oc -n ${devProject} set image dc/${backendImageName} ${backendImageName}=${devProject}/${backendImageName}:${devTag} --source=imagestreamtag"
                    sh "oc -n ${devProject} set env dc/${backendImageName} VERSION=\"${devTag} (${backendImageName}-dev)\""
                    rollout(devProject, backendImageName)

                    // deploy frontend
                    sh "oc -n ${devProject} set image dc/${frontendImageName} ${frontendImageName}=${devProject}/${frontendImageName}:${devTag} --source=imagestreamtag"
                    sh "oc -n ${devProject} set env dc/${frontendImageName} VERSION=\"${devTag} (${frontendImageName}-dev)\""
                    rollout(devProject, frontendImageName)
                }
            }
        }
        stage('Integration Test') {
            steps {
                container('python') {
                    sh 'echo *** TODO: Add robotframework integration tests'
                }
            }
        }
    }
}

void rollout(String project, String name) {
    script {
        // Use the OpenShift Plugin to rollout and wait for at least 1 pod in "Running" state
        openshift.withCluster() {
            openshift.withProject(project) {
                def rm = openshift.selector("dc", "${name}").rollout().latest()
                timeout(5) {
                    openshift.selector("dc", "${name}").related('pods').untilEach(1) {
                        return (it.object().status.phase == "Running")
                    }
                }
            }
        }
    }
}

void dumpPipelineConfig() {
    sh "echo *************************************"
    sh "echo *      Pipeline Configuration       *"
    sh "echo *************************************"
    sh "echo appName = ${appName}"
    sh "echo frontendImageName = ${frontendImageName}"
    sh "echo backendImageName = ${backendImageName}"
    sh "echo devProject = ${devProject}"
    sh "echo prodProject = ${prodProject}"
    sh "echo devTag = ${devTag}"
    sh "echo prodTag = ${prodTag}"
    sh "echo destApp = ${destApp}"
    sh "echo activeApp = ${activeApp}"
    sh "echo *************************************"
}